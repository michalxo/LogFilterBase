package org.ngmon.logger.logtranslator.generator;

import org.ngmon.logger.logtranslator.common.Log;
import org.ngmon.logger.logtranslator.common.LogFile;
import org.ngmon.logger.logtranslator.common.Utils;
import org.ngmon.logger.logtranslator.ngmonLogging.LogTranslatorNamespace;

import java.util.List;

public class HelperGenerator {

    private static LogTranslatorNamespace LOG = Utils.getLogger();

    /**
     * Generate few namespaces for this logging application. Resolve number of namespaces
     * for this app based on applicationNamespaceLength property and set them to LogFiles.
     *
     * @param logFileList input list of logFiles, which contain only filepath and package qualified name.
     * @return same list of logFiles, but each of them has filled appropriate namespace.
     */
    public static List<LogFile> generateNamespaces(List<LogFile> logFileList) {
        LOG.applicationNamespaceLength(Utils.getApplicationNamespaceLength()).trace();
        for (LogFile lf : logFileList) {
//            System.out.println("packageName=" + lf.getPackageName());
            if (lf.getPackageName() == null) {
                LOG.emptyPackageNameInFile(lf.getFilepath()).error();
//                System.err.println("null packageName in file " + lf.getFilepath());
            }
            String namespace = createNamespace(lf.getPackageName());
//            namespaceSet.add(namespace);
            lf.setNamespace(namespace);
        }

        return logFileList;
    }

    /**
     * Create NGMON log namespace which will contain all calls for this logs.
     * This method sets granularity level of NGMON log messages.
     * If original packageName length is longer then applicationNamespaceLength
     * property, make it shorter.
     *
     * @param packageName string to change
     * @return shortened packageName from NGMON length rules
     */
    private static String createNamespace(String packageName) {
        int numberOfDots = Utils.numberOfDotsInText(packageName);

        if (numberOfDots < Utils.getApplicationNamespaceLength()) {
            return packageName;
        } else {
            StringBuilder newPackageName = new StringBuilder();
            String[] pckgs = packageName.split("\\.", Utils.getApplicationNamespaceLength() + 1);
            pckgs[pckgs.length - 1] = "";
            for (String p : pckgs) {
                if (!p.equals("")) newPackageName.append(p).append(".");
            }
            // remove last extra dot
            newPackageName.deleteCharAt(newPackageName.length() - 1);
            return newPackageName.toString();
        }
    }

    /**
     * Generate method nam from 'comments' list - strings found in given log method call.
     * If comment list is empty, use autogenerated method name from property file.
     *
     * @param log to generate and set method log from
     */
    public static void generateMethodName(Log log) {
        if (log.getComments().size() == 0) {
            StringBuilder tempName = new StringBuilder();
            for (LogFile.Variable var : log.getVariables()) {
                if (var.getNgmonName() != null) {
                    tempName.append(var.getNgmonName());
                } else {
                    tempName.append(var.getName());
                }
            }
            int maxLengthUtils = Utils.getNgmonEmptyLogStatementMethodNameLength();
            int maxLength = (tempName.length() < maxLengthUtils) ? tempName.length() : maxLengthUtils;
            log.setMethodName(tempName.substring(0, maxLength) + Utils.getNgmonEmptyLogStatement());
        } else {
            StringBuilder logName = new StringBuilder();
            int counter = 0;
            int logNameLength = Utils.getNgmonLogLength();
            for (String comment : log.getComments()) {
                for (String str : comment.split(" ")) {
                    if (!Utils.BANNED_LIST.contains(str)) {
                        if (counter != 0) {
                            logName.append("_");
                        }
                        logName.append(str);
                        counter++;
                    }
                    if (counter >= logNameLength) break;
                }
            }
            log.setMethodName(logName.toString());
//            System.out.println("\told=" + log.getComments().toString() + "\n\tnew=" + logName.toString());
        }
    }


    /**
     * Generate new log method call which will be replaced by 'original' log method call.
     * This new log method will use NGMON logger. Which is goal of this mini-application.
     *
     * @param logName name of current logger variable (mostly "LOG")
     * @param log current log to get information from
     * @return log method calling in NGMON's syntax form
     */
    public static String generateLogMethod(String logName, Log log) {
        // TODO/wish - if line is longer then 80 chars, append to newline!
        if (log != null) {
            // generate variables
            StringBuilder vars = new StringBuilder();
            StringBuilder tags = new StringBuilder();

            LOG.variablesInLog(log.getVariables().toString()).trace();
//            System.out.println("\t" + log.getVariables() + "\n\t" + log.getOriginalLog() );
            for (LogFile.Variable var : log.getVariables()) {
                if (var.getChangeOriginalName() == null) {
                    vars.append(var.getName());
                } else {
                    vars.append(var.getChangeOriginalName());
                }
                // Append .toString() if variable is of any other type then NGMON allowed data types
                if (!Utils.listContainsItem(Utils.NGMON_ALLOWED_TYPES, var.getType())) {
                    vars.append(".toString()");
                }

                if (!var.equals(log.getVariables().get(log.getVariables().size() - 1))) {
                    vars.append(", ");
                }
            }

            // generate tags
            if (log.getTag() != null) {
                int tagSize = log.getTag().size();
                if (tagSize == 0) {
                    tags = null;
                } else {
                    for (int i = 0; i < tagSize; i++) {
                        tags.append(".tag(\"").append(log.getTag().get(0)).append("\")");
                    }
                }
            }
//            System.out.printf("generating=%s.%s(%s)%s%s;", "LOG", log.getMethodName(), vars, tags, log.getLevel());
            String replacementLog = String.format("%s.%s(%s)%s.%s()", logName, log.getMethodName(), vars, tags, log.getLevel());
            LOG.replacementLogOriginalLog(replacementLog, log.getOriginalLog()).trace();
            log.setGeneratedReplacementLog(replacementLog);
            return replacementLog;
        } else {
            return null;
        }
    }

    public static String generateEmptySpaces(int numberOfSpaces) {
        StringBuilder spaces = new StringBuilder();
        while (numberOfSpaces > 0) {
            spaces.append(" ");
            numberOfSpaces--;
        }
        return spaces.toString();
    }

    public static String addStringTypeCast(String typecastMe) {
        return "String.valueOf(" + typecastMe + ")";
    }
}
